INSERT INTO "isad_theory" VALUES  (1,'Identifying the Requirements from Problem Statements','<h2>Requirements</h2><p>Sommerville defines &quot;requirement&quot; [1] as a specification of what should be implemented. Requirements specify how the target system should behave. It specifies what to do, but not how to do. Requirements engineering refers to the process of understanding what a customer expects from the system to be developed, and to document them in a standard and easily readable and understandable format. This documentation will serve as reference for the subsequent design, implementation and verification of the system.</p><p>It is necessary and important that before we start planning, design and implementation of the software system for our client, we are clear about its requirements. If we do not have a clear vision of what is to be developed and what all features are expected, there would be serious problems, and customer dissatisfaction as well.</p><h2>Characteristics of Requirements</h2><p>Requirements gathered for any new system to be developed should exhibit the following three properties:</p><ul>    <li>    <strong>Unambiguity:</strong> There should not be any ambiguity what a    system to be developed should do. For example, consider you are developing a web     application for your client. The client requires that enough number of people     should be able to access the application simultaneously. What is the &quot;enough     number of people&quot;? That could mean 10 to you, but perhaps 100 to the client.    There''s an ambiguity.    </li>    <li>    <strong>Consistency:</strong> To illustrate this, consider the automation     of a nuclear plant. Suppose one of the clients say that it the radiation level     inside the plant exceeds R1, all reactors should be shut down. However, another    person from the client side suggests that the threshold radiation level should    be R2. Thus, there is an inconsistency between the two end users regarding what    they consider as threshold level of radiation.    </li>    <li>    <strong>Completeness:</strong> A particular requirement for a system     should specify what the system should do and also what it should not. For     example, consider a software to be developed for ATM. If a customer enters an     amount greater than the maximum permissible withdrawal amount, the ATM should     display an error message, and it should not dispense any cash.    </li></ul><h2>Categorization of Requirements</h2><p>Based on the target audience or subject matter, requirements can be classified into different types, as stated below:</p><ul>    <li>    <strong>User requirements: </strong>They are written in natural language    so that both customers can verify their requirements have been correctly    identified    </li>    <li>    <strong>System requirements: </strong>They are written involving technical     terms and/or specifications, and are meant for the development or testing     teams    </li></ul><p>Requirements can be classified into two groups based on what they describe:</p><ul>    <li>    <strong>Functional requirements (FRs): </strong>These describe the     functionality of a system -- how a system should react to a particular set     of inputs and what should be the corresponding output.    </li>    <li>    <strong>Non-functional requirements (NFRs): </strong>They are not directly     related what functionalities are expected from the system. However, NFRs     could typically define how the system should behave under certain situations.     For example, a NFR could say that the system should work with 128MB RAM.     Under such condition, a NFR could be more critical than a FR.    </li></ul><p>Non-functional requirements could be further classified into different types like:</p><ul>    <li>    <strong>Product requirements:</strong> For example, a specification that     the web application should use only plain HTML, and no frames    </li>    <li>    <strong>Performance requirements:</strong> For example, the system should     remain available 24x7    </li>    <li>    <strong>Organizational requirements:</strong> The development process should     comply to SEI CMM level 4    </li></ul><h2>Functional Requirements</h2><h3>Identifying Functional Requirements</h3><p>Given a problem statement, the functional requirements could be identified by focusing on the following points:</p><ul>    <li>    Identify the high level functional requirements simply from the conceptual     understanding of the problem. For example, a Library Management System, apart    from anything else, should be able to issue and return books.    </li>    <li>    Identify the cases where an end user gets some meaningful work done by using     the system. For example, in a digital library a user might use     the &quot;Search Book&quot; functionality to obtain information about the books of his     interest.    </li>    <li>    If we consider the system as a black box, there would be some inputs to it,    and some output in return. This black box defines the functionalities of the    system. For example, to search for a book, user gives title of the book as     input and get the book details and location as the output.    </li>    <li>    Any high level requirement identified could have different sub-requirements.    For example, &quot;Issue Book&quot; module could behave differently for    different class of users, or for a particular user who has issued the book    thrice consecutively.    </li></ul><h2>Preparing Software Requirements Specifications</h2><p>Once all possible FRs and non-FRs have been identified, which are complete, consistent, and non-ambiguous, the Software Requirements Specification (SRS) is to be prepared. IEEE provides a template  [iv], also available <a href="http://www.cse.msu.edu/~cse870/IEEEXplore-SRS-template.pdf">here</a>, which could be used for this purpose. The SRS is prepared by the service provider, and verified by its client. This document serves as a legal agreement between the client and the service provider. Once the concerned system has been developed and deployed, and a proposed feature was not found to be present in the system, the client can point this out from the SRS. Also, if after delivery, the client says a new feature is required, which was not mentioned in the SRS, the service provider can again point to the SRS. The scope of the current experiment, however, does not cover writing a SRS.</p>','<ul><li>Identify ambiguities, inconsistencies and incompleteness from a requirements specification</li><li>Identify and state functional requirements</li><li>Identify and state non-functional requirements</li></ul>','3.00','<p>Requirements identification is the first step of any software development project.  Until the requirements of a client have been clearly identified, and verified, no other task (design, coding, testing) could begin. Usually business analysts having domain knowledge on the subject matter discuss with clients and decide what features are to be implemented.</p><p>In this experiment we will learn how to identify functional and non-functional requirements from a given problem statement. Functional and non-functional requirements are the primary components of a Software Requirements Specification.</p>'),
 (2,'Estimation of Project Metrics','<h2>Project Estimation Techniques</h2><p>A software project is not just about writing a few hundred lines of source code to achieve a particular objective. The scope of a software project is comparatively <i>quite large</i>, and such a project could take several years to complete. However, the phrase &quot;quite large&quot; could only give some (possibly vague) qualitative information. As in any other science and engineering discipline, one would be interested to <i>measure</i> how complex a project is. One of the major activities of the project planning phase, therefore, is to estimate various project parameters in order to take proper decisions. Some important project parameters that are estimated include:   <ul>    <li>    <strong>Project size:</strong> What would be the size of the code written     say, in number of lines, files, modules?    </li>    <li>    <strong>Cost:</strong> How much would it cost to develop a software? A    software may be just pieces of code, but one has to pay to the managers,    developers, and other project personnel.    </li>    <li>    <strong>Duration:</strong> How long would it be before the software is    delivered to the clients?    </li>    <li>    <strong>Effort:</strong> How much effort from the team members would be     required to create the software?    </li>  </ul></p><p>In this experiment we will focus on two methods for estimating project metrics: COCOMO and Halstead''s method.</p><h2>COCOMO</h2><p>COCOMO (Constructive Cost Model) was proposed by Boehm. According to him, there could be three categories of software projects: organic, semidetached, and embedded. The classification is done considering the characteristics of the software, the development team and environment. These product classes typically correspond to application, utility and system programs, respectively. Data processing programs could be considered as application programs. Compilers, linkers, are examples of utility programs. Operating systems, real-time system programs are examples of system programs. One could easily apprehend that it would take much more time and effort to develop an OS than an attendance management system.</p><p>The concept of organic, semidetached, and embedded systems are described below.<ul><li><strong>Organic:</strong> A development project is said to be of organic type, if   <ul style="font-size: 0.9em;">    <li>The project deals with developing a well understood application</li>    <li>The development team is small</li>    <li>The team members have prior experience in working with similar types of     projects</li>  </ul></li><li><strong>Semidetached:</strong> A development project can be categorized as semidetached type, if   <ul style="font-size: 0.9em;">    <li>The team consists of some experienced as well as inexperienced     staff</li>    <li>Team members may have some experience on the type of system to be     developed</li>  </ul></li><li><strong>Embedded:</strong> Embedded type of development project are those, which  <ul style="font-size: 0.9em;">    <li>Aims to develop a software strongly related to machine hardware</li>    <li>Team size is usually large</li>  </ul></li></p><p>                                                    Boehm suggested that estimation of project parameters should be done through three stages: Basic COCOMO, Intermediate COCOMO, and Complete COCOMO.</p><h3>Basic COCOMO Model</h3><p>The basic COCOMO model helps to obtain a rough estimate of the project parameters. It estimates effort and time required for development in the following way: <br>                                <span class="contentEquation">Effort = a * (KDSI)<sup>b</sup> PM </span>                                                   <span class="contentEquation">Tdev = 2.5 * (Effort)<sup>c</sup> Months </span>                        where<ul>  <li>KDSI is the estimated size of the software expressed in Kilo Delivered Source Instructions</li>  <li>a, b, c are constants determined by the category of software project</li>  <li>Effort denotes the total effort required for the software development,   expressed in person months (PMs)</li>  <li>Tdev denotes the estimated time required to develop the software   (expressed in months)</li>  </ul></p><p>The value of the constants a, b, c are given below: <br> <br><table class="data"><thead><tr><th>Software project</th><th><i>a</i></th><th><i>b</i></th><th><i>c</i></th></tr></thead><tbody><tr><td style="text-align: left;">Organic</td><td>2.4</td><td>1.05</td><td>0.38</td></tr><tr><td style="text-align: left;">Semi-detached</td><td>3.0</td><td>1.12</td><td>0.35</td></tr><tr><td style="text-align: left;">Embedded</td><td>3.6</td><td>1.20</td><td>0.32</td></tr></tbody></table></p><h3>Intermediate COCOMO Model</h3><p>The basic COCOMO model considers that effort and development time depends only on the size of the software. However, in real life there are many other project parameters that influence the development process. The intermediate COCOMO take those other factors into consideration by defining a set of 15 cost drivers (multipliers) as shown in the Table below [i]. Thus, any project that makes use of modern programming practices would have lower estimates in terms of effort and cost. Each of the 15 such attributes can be rated on a six-point scale ranging from "very low" to "extra high" in their relative order of importance. Each attribute has an effort multiplier fixed as per the rating. The product of effort multipliers of all the 15 attributes gives the <strong>Effort Adjustment Factor (EAF)</strong>. <br> <br><table class="data" cellpadding="0" cellspacing="0"><caption>Cost drivers for Intermediate COCOMO (Source: <a href="http://en.wikipedia.org/wiki/COCOMO">http://en.wikipedia.org/wiki/COCOMO</a>)</caption><thead><tr><th rowspan="2" valign="bottom">Cost Drivers</td><th colspan="6">Ratings</th></tr><tr><th valign="bottom" width="10%" align="center">Very Low</td><th valign="bottom" width="10%" align="center">Low</td><th valign="bottom" width="10%" align="center">Nominal</td><th valign="bottom" width="10%" align="center">High</td><th valign="bottom" width="10%" align="center">Very High</td><th valign="bottom" width="10%" align="center">Extra High</td></tr></thead><tbody><tr><th align="left" style="background-color: #dddddd;">Product attributes</th></tr><tr><td style="text-align: left;">Required software reliability</td><td align="center">0.75</td><td align="center">0.88</td><td align="center">1.00</td><td align="center">1.15</td><td align="center">1.40</td><td align="center"> </td></tr><tr><td style="text-align: left;">Size of application database</td><td align="center"> </td ><td align="center">0.94</td><td align="center">1.00</td><td align="center">1.08</td><td align="center">1.16</td><td align="center"> </td></tr><tr><td style="text-align: left;">Complexity of the product</td><td align="center">0.70</td><td align="center">0.85</td><td align="center">1.00</td><td align="center">1.15</td><td align="center">1.30</td><td align="center">1.65</td></tr><tr><th align="left" style="background-color: #dddddd;">Hardware attributes</th></tr><tr><td style="text-align: left;">Run-time performance constraints</td><td align="center"> </td><td align="center"> </td><td align="center">1.00</td><td align="center">1.11</td><td align="center">1.30</td><td align="center">1.66</td></tr><tr><td style="text-align: left;">Memory constraints</td><td align="center"> </td><td align="center"> </td><td align="center">1.00</td><td align="center">1.06</td><td align="center">1.21</td><td align="center">1.56</td></tr><tr><td style="text-align: left;">Volatility of the virtual machine environment</td><td align="center"> </td><td align="center">0.87</td><td align="center">1.00</td><td align="center">1.15</td><td align="center">1.30</td><td align="center"> </td></tr><tr><td style="text-align: left;">Required turnabout time</td><td align="center"> </td><td align="center">0.87</td><td align="center">1.00</td><td align="center">1.07</td><td align="center">1.15</td><td align="center"> </td></tr><tr><th align="left" style="background-color: #dddddd;">Personnel attributes</th></tr><tr><td style="text-align: left;">Analyst capability</td><td align="center">1.46</td><td align="center">1.19</td><td align="center">1.00</td><td align="center">0.86</td><td align="center">0.71</td><td align="center"> </td></tr><tr><td style="text-align: left;">Applications experience</td><td align="center">1.29</td><td align="center">1.13</td><td align="center">1.00</td><td align="center">0.91</td><td align="center">0.82</td><td align="center"> </td></tr><tr><td style="text-align: left;">Software engineer capability</td><td align="center">1.42</td><td align="center">1.17</td><td align="center">1.00</td><td align="center">0.86</td><td align="center">0.70</td><td align="center"> </td></tr><tr><td style="text-align: left;">Virtual machine experience</td><td align="center">1.21</td><td align="center">1.10</td><td align="center">1.00</td><td align="center">0.90</td><td align="center"> </td><td align="center"> </td></tr><tr><td style="text-align: left;">Programming language experience</td><td align="center">1.14</td><td align="center">1.07</td><td align="center">1.00</td><td align="center">0.95</td><td align="center"> </td><td align="center"> </td></tr><tr><th align="left" style="background-color: #dddddd;">Project attributes</th></tr><tr><td style="text-align: left;">Application of software engineering methods</td><td align="center">1.24</td><td align="center">1.10</td><td align="center">1.00</td><td align="center">0.91</td><td align="center">0.82</td><td align="center"> </td></tr><tr><td style="text-align: left;">Use of software tools</td><td align="center">1.24</td><td align="center">1.10</td><td align="center">1.00</td><td align="center">0.91</td><td align="center">0.83</td><td align="center"> </td></tr><tr><td style="text-align: left;">Required development schedule</td><td align="center">1.23</td><td align="center">1.08</td><td align="center">1.00</td><td align="center">1.04</td><td align="center">1.10</td></tr></tbody></table><br> <br>EAF is used to refine the estimates obtained by basic COCOMO as follows:<span class="contentEquation">Effort|<sub>corrected</sub> = Effort * EAF</span><span class="contentEquation">Tdev|<sub>corrected</sub> = 2.5 * (Effort|<sub>corrected</sub>) <sup>c</sup></span></p><h3>Complete COCOMO Model</h3><p>Both the basic and intermediate COCOMO models consider a software to be a single homogeneous entity -- an assumption, which is rarely true. In fact, many real life applications are made up of several smaller sub-systems. (One might not even develop all the sub-systems -- just use the available services). The complete COCOMO model takes these factors into account to provide a far more accurate estimate of project metrics.</p><p>To illustrate this, consider a very popular distributed application: the ticket booking system of the Indian Railways. There are computerized ticket counters in most of the railway stations of our country. Tickets can be booked / canceled from any such counter. Reservations for future tickets, cancellation of reserved tickets could also be performed. On a high level, the ticket booking system has three main components:<ul>  <li>Database</li>  <li>Graphical User Interface (GUI)</li>  <li>Networking facilities</li></ul></p><p>Among these, development of the GUI is considered as an organic project type; the database module could be considered as a semi-detached software. The networking module can be considered as an embedded software. To obtain a realistic cost,one should estimate the costs for each component separately, and then add it up.</p><h2>Advantages of COCOMO</h2><p>COCOMO is a simple model, and should help one to understand the concept of project metrics estimation. </p><h2>Drawbacks of COCOMO</h2><p>COCOMO uses KDSI, which is not a proper measure of a program''s size. Indeed, estimating the size of a software is a difficult task, and any slight miscalculation could cause a large deviation in subsequent project estimates. Moreover, COCOMO was proposed in 1981 keeping the waterfall model of project life cycle in mind [2]. It fails to address other popular approaches like prototype, incremental, spiral, agile models. Moreover, in present day a software project may not necessarily consist of coding of every bit of functionality. Rather, existing software components are often used and glued together towards the development of a new software. COCOMO is not suitable in such cases.</p><p>COCOMO II was proposed later in 2000 to many of address these issues.</p><h2>Halstead''s Complexity Metrics</h2><p>Halstead took a linguistic approach to determine the complexity of a program. According to him, a computer program consists of a collection of different operands and operators. The definition of operands and operators could, however,vary from one person to another and one programming language to other. Operands are usually the implementation variables or constants -- something upon which an operation could be performed. Operators are those symbols that affects the value of operands. Halstead''s metrics are computed based on the operators and operands used in a computer program. Any given program has the following four parameters:<ul><li><strong>n1</strong>: Number of unique operators used in the program</li><li><strong>n2</strong>: Number of unique operands used in the program</li><li><strong>N1</strong>: Total number of operators used in the program</li><li><strong>N2</strong>: Total number of operands used in the program</li></ul>Using the above parameters one compute the following metrics:</p><ul><li><strong>Program Length</strong>: N = N1 + N2</li><li><strong>Program Vocabulary</strong>: n = n1 + n2</li><li><strong>Volume</strong>: V = N * lg n</li><li><strong>Difficulty</strong>: D = (n1 * N2) / (2 * n2)</li><li><strong>Effort</strong>: E = D * V</li><li><strong>Time to Implement</strong>: T = E / 18 (in seconds) [vi]</li></ul><p>The program volume V is the minimum number of bits needed to encode the program. It represents the size of the program while taking into account the programming language. <br>The difficulty metric indicates how difficult a program is to write or understand. <br>Effort denotes the "mental effort" required to develop the software, or to recreate the same in another programming language [iv].</p>','<ul>  <li>Categorize projects using COCOMO, and estimate effort and development time required for a project</li>  <li>Estimate the program complexity and effort required to recreate it using Halstead''s metrics</li></ul>','3.00','<p>After gathering the entire requirements specific to software project usually we need to think about different solution strategy for the project. Expert business analysts are analyzing their benefits and as well as their shortcomings by means of cost, time and resources require to develop it. </p><p>In this experiment, we will learn how to estimate cost, effort and duration for a software project, and then select one solution approach which will be found suitable to fulfill the organizational goal. </p>'),
 (3,'Modeling UML Use Case Diagrams and Capturing Use Case Scenarios','<h2>Use case diagrams</h2><p>Use case diagrams belong to the category of behavioural diagram of UML diagrams.Use case diagrams aim to present a graphical overview of the functionality provided by the system. It consists of a set of actions (referred to as use cases) that the concerned system can perform, one or more actors, and dependencies among them. </p><h3>Actor</h3><p>An actor can be defined as [1] an object or set of objects, external to the system, which interacts with the system to get some meaningful work done. Actors could be human, devices, or even other systems.</p><p>For example, consider the case where a customer <em>withdraws cash</em> from an ATM. Here, customer is a human actor.</p><p>Actors can be classified as below [2], [i]:<ul>    <li>    <strong>Primary actor</strong>: They are principal users of the system, who    fulfill their goal by availing some service from the system. For example, a     customer uses an ATM to withdraw cash when he needs it. A customer is the     primary actor here.    </li>    <li>    <strong>Supporting actor</strong>: They render some kind of service to the     system. "Bank representatives", who replenishes the stock of cash, is such     an example. It may be noted that replenishing stock of cash in an ATM is not     the prime functionality of an ATM.    </li>    </ul></p><p>    In a use case diagram primary actors are usually drawn on the top left side of the diagram.</p><h3>Use Case</h3><p>A use case is simply [1] a functionality provided by a system.</p><p>Continuing with the example of the ATM, <em>withdraw cash</em> is a functionality that the ATM provides. Therefore, this is a use case. Other possible use cases includes, <em>check balance</em>, <em>change PIN</em>, and so on. </p><p>Use cases include both successful and unsuccessful scenarios of user interactions with the system. For example, authentication of a customer by the ATM would fail if he enters wrong PIN. In such case, an error message is displayed on the screen of the ATM.</p><h3>Subject</h3><p>Subject is simply [iii] the system under consideration. Use cases apply to a subject. For example, an ATM is a subject, having multiple use cases, and multiple actors interact with it.However, one should be careful of external systems interacting with the subject as actors.</p><h2>Graphical Representation</h2><p>An actor is represented by a stick figure and name of the actor is written below it. A use case is depicted by an ellipse and name of the use case is written inside it. The subject is shown by drawing a rectangle. Label for the system could be put inside it. Use cases are drawn inside the rectangle, and actors are drawn outside the rectangle, as shown in Figure 1.    <img class="diagram" alt="Use case diagram" style="display: block;"    src="use_case_1.png">Figure 1: A use case diagram for a book store.</p><h2>Association between Actors and Use Cases</h2><p>A use case is triggered by an actor. Actors and use cases are connected through binary associations indicating that the two communicates through message passing.</p><p>An actor must be associated with at least one use case. Similarly, a given use case must be associated with at least one actor. Association among the actors are usually not shown. However, one can depict the class hierarchy among actors.</p><h2>Use Case Relationships</h2><p>Three types of relationships exist among use cases:<ul>    <li>Include relationship</li>    <li>Extend relationship</li>    <li>Use case generalization</li></ul></p><h3>Include Relationship</h3><p>Include relationships are used to depict common behaviour that are shared by multiple use cases. This could be considered analogous to writing functions in a program in order to avoid repetition of writing the same code. Such a function would be called from different points within the program.</p><h4>Example</h4><p>For example, consider an email application. A user can send a new mail, reply to an email he has received, or forward an email. However, in each of these three cases, the user must be logged in to perform those actions. Thus, we could have a <em>login</em> use case, which is included by <em>compose mail</em>, <em>reply</em>, and <em>forward email</em> use cases. The relationship is shown in Figure 2.<center>    <img class="diagram" alt="Include relationship"     src="use_case_include.png">Figure 2: Include relationship between use cases.</center></p><h4>Notation</h4><p>Include relationship is depicted by a dashed arrow with a &laquo;include&raquo; stereotype from the including use case to the included use case.</p><h3>Extend Relationship</h3><p>Use case extensions are used used to depict any variation to an existing use case. They are used to the specify the changes required when any assumption made by the existing use case becomes false [iv, v].</p><h4>Example</h4><p>Let''s consider an online bookstore. The system allows an authenticated user to buy selected book(s). While the order is being placed, the system also allows to  specify any special shipping instructions [vii], for example, call the customer before delivery. This <em>Shipping Instructions</em> step is optional, and not a part of the main <em>Place Order</em> use case. Figure 3 depicts such relationship.<center>    <img class="diagram" alt="Extend relationship"     src="use.png">Figure 3: Extend relationship between use cases.</center></p><h4>Notation</h4><p>Extend relationship is depicted by a dashed arrow with a &laquo;extend&raquo; stereotype from the extending use case to the extended use case.</p><h3>Generalization Relationship</h3><p>Generalization relationship are used to represent the inheritance between use cases. A derived use case specializes some functionality it has already inherited from the base use case.</p><h4>Example</h4><p>To illustrate this, consider a graphical application that allows users to draw polygons. We could have a use case <em>draw polygon</em>. Now, rectangle is a particular instance of polygon having four sides at right angles to each other. So, the use case <em>draw rectangle</em> inherits the properties of the use case <em>draw polygon</em> and overrides its drawing method. This is an example of generalization relationship. Similarly, a generalization relationship exists between <em>draw rectangle</em> and <em>draw square</em> use cases. The relationship has been illustrated in Figure 4.<center>    <img class="diagram" alt="Generalization relationship"     src="use_case_generalize.png">Figure 4: Generalization relationship among use cases.</center></p><h4>Notation</h4><p>Generalization relationship is depicted by a solid arrow from the specialized (derived) use case to the more generalized (base) use case.</p><h2>Identifying Actors</h2><p>Given a problem statement, the actors can be identified by asking the following questions [2]:<ul>    <li>Who gets most of the benefits from the system? (The answer would lead to    the identification of the primary actor)</li>    <li>Who keeps the system working?     (This will help to identify a list of potential users)</li>    <li>What other software / hardware does the system interact with?</li>    <li>Any interface (interaction) between the concerned system and any other     system?</li></ul></p><h2>Identifying Use cases</h2><p>Once the primary and secondary actors have been identified, we have to find out their goals -- what are the functionality they can obtain from the system. Any use case name should start with a verb like, &quot;Check balance&quot;.</p><h2>Guidelines for drawing Use Case diagrams</h2><p>Following general guidelines could be kept in mind while trying to draw a use case diagram [1]:<ul>    <li>Determine the system boundary</li>    <li>Ensure that individual actors have well-defined purpose</li>    <li>Use cases identified should let some meaningful work done by the actors    </li>    <li>Associate the actors and use cases -- there should no be any     actor or use case floating without any connection</li>    <li>Use include relationship to encapsulate common behaviour among use cases    , if any</li></ul><p><p>Also look at [ix] for further tips.</p>','<ul>  <li>How to identify different actors and use cases from a given problem statement</li>  <li>How to associate use cases with different types of relationships</li>  <li>How to draw a use-case diagram</li></ul>','3.00','<p>Use case diagram is a platform that can provide a common understanding for the end-users, developers and the domain experts. It is used to capture the basic functionality i.e. use cases, and the users of those available functionality, i.e. actors, from a given problem statement. </p><p>In this experiment, we will learn how use cases and actors can be captured and how different use cases are related in a system. </p>'),
 (4,'E-R Modeling from the Problem Statements','<h2>Entity Relationship Model</h2><p>Entity-Relationship model is used to represent a logical design of a database to be created. In ER model, real world objects (or concepts) are abstracted as entities, and different possible associations among them are modeled as relationships.</p><p>For example, student and school -- they are two entities. Students study in school. So, these two entities are associated with a relationship "Studies in".</p><p>As another example, consider a system where some job runs every night, which updates the database. Here, job and database could be two entities. They are associated with the relationship "Updates".</p><h2>Entity Set and Relationship Set</h2><p>An entity set is a collection of all similar entities. For example, "Student" is an entity set that abstracts all students. Ram, John are specific entities belonging to this set. Similarly, a "Relationship" set is a set of similar relationships.</p><h2>Attributes of Entity</h2><p>Attributes are the characteristics describing any entity belonging to an entity set. Any entity in a set can be described by zero or more attributes.</p><p>For example, any student has got a name, age, an address. At any given time a student can study only at one school. In the school he would have a roll number, and of course a grade in which he studies. These data are the attributes of the entity set Student. </p><h2>Keys</h2><p>One or more attribute(s) of an entity set can be used to define the following keys:</p><ul>    <li>    <strong>Super key:</strong> One or more attributes, which when taken     together, helps to uniquely identify an entity in an entity set. For     example, a school can have any number of students. However, if we know grade     and roll number, then we can uniquely identify a student in that school.    </li>    <li>    <strong>Candidate key:</strong> It is a minimal subset of a super key. In     other words, a super key might contain extraneous attributes, which do not    help in identifying an object uniquely. When such attributes are removed,     the key formed so is called a candidate key.    </li>    <li>    <strong>Primary key:</strong> A database might have more than one    candidate key. Any candidate key chosen for a particular implementation of     the database is called a primary key.    </li>    <li>    <strong>Prime attribute:</strong> Any attribute taking part in a super     key    </li></ul><h2>Weak Entity</h2><p>An entity set is said to be weak if it is dependent upon another entity set. A weak entity cannot be uniquely identified only by its attributes. In other words, it does not have a super key.</p><p>For example, consider a company that allows employees to have travel allowance for their immediate family. So, here we have two entity sets: employee and family, related by "Can claim for". However, family does not have a super key. Existence of a family is entirely dependent on the concerned employee. So, it is meaningful only with reference to employee.</p><h2>Entity Generalization and Specialization</h2><p>Once we have identified the entity sets, we might find some similarities among them. For example, multiple person interacts with a banking system. Most of them are customers, and rest employees or other service providers. Here, customers, employees are persons, but with certain specializations. Or in other way, person is the generalized form of customer and employee entity sets.</p><p>ER model uses the "ISA" hierarchy to depict specialization (and thus, generalization).</p><h2>Mapping Cardinalities</h2><p>One of the main tasks of ER modeling is to associate different entity sets. Let''s consider two entity sets E1 and E2 associated by a relationship set R. Based on the number of entities in E1 and E2 are associated with, we can have the following four type of mappings:<ul>    <li>    <strong>One to one:</strong> An entity in E1 is related to at most a single    entity in E2, and vice versa    </li>    <li>    <strong>One to many:</strong> An entity in E1 could be related to zero or     more entities in E2. Any entity in E2 could be related to at most a single     entity in E1.    </li>    <li>    <strong>Many to one:</strong> Zero or more number of entities in E1 could be     associated to a single entity in E2. However, an entity in E2 could be     related to at most one entity in E1.    </li>    <li>    <strong>Many to many:</strong> Any number of entities could be related to     any number of entities in E2, including zero, and vice versa.    </li></ul></p>	<h2>ER Diagram</h2><p>From a given problem statement we identify the possible entity sets, their attributes, and relationships among different entity sets. Once we have these information, we represent them pictorially, called an entity-relationship (ER) diagram.</p><h2>Graphical Notations for ER Diagram</h2></p><table class="techno" style="width: 800px;"><thead>  <tr style="text-align: center;">    <th>Term</th>    <th>Notation</th>    <th>Remarks</th>  </tr></thead><tbody style="text-align: left;">  <tr>    <td>Entity set</td>    <td><img src="entity.png" alt="Entity" >    </td>    <td>    Name of the set is written inside the rectangle    </td>  </tr>  <tr>    <td>Attribute</td>    <td><img src="attribute.png" alt="Attribute" >    </td>    <td>    Name of the attribute is written inside the ellipse    </td>  </tr>  <tr>    <td>Entity with attributes</td>    <td><img src="entity_attributes.png"     alt="Entity with attributes">    </td>    <td>Roll is the primary key; denoted with an underline</td>  </tr>  <tr>    <td>Weak entity set</td>    <td><img src="weak_entity.png"     alt="Weak entity" >    </td>    <td></td>  </tr>  <tr>    <td>Relationship set</td>    <td><img src="relationship.png"     alt="Relationship" >    </td>    <td>    Name of the relationship is written inside the diamond    </td>  </tr>  <tr>    <td>Related enity sets</td>    <td><img src="entity_relationship.png"     alt="Entity relationship" >    </td>    <td></td>  </tr>  <tr>    <td>Relationship cardinality</td>    <td><img src="relationship_cardinality.png"     alt="Relationship cardinality" >    </td>    <td>A person can own zero or more cars but no two persons can own the same     car</td>  </tr>  <tr>    <td>Relationship with weak entity set</td>    <td><img src="weak_entity_relationship.png"     alt="Weak entity relationship" >    </td>    <td></td>  </tr></tbody></table><p><h2>Importance of ER modeling</h2><p>Figure 1 shows the different steps involved in implementation of a (relational) database.<br><center><img src="database_design_steps.png" id="diagram" alt="Database design steps" >Figure 1: Steps to implement a RDBMS.</center></p><p>Given a problem statement, the first step is to identify the entities, attributes and relationships. We represent them using an ER diagram. Using this ER diagram, table structures are created, along with required constraints. Finally, these tables are normalized in order to remove redundancy and maintain data integrity. Thus, to have data stored efficiently, the ER diagram is to be drawn as much detailed and accurate as possible.</p>','<ul><li>Identify entity sets, their attributes, and various relationships</li><li>Represent the data model through ER diagram</li></ul>','3.00','<p>Developing databases is a very important task to develop a system. Before going to form exact database tables and establishing relationships between them, we conceptually or logically can model our database using ER diagrams. </p><p>In this experiment we will learn how to find the entities, its attributes and how the relationships between the entities can be established for a system. </p>'),
 (5,'Identifying Domain Classes from the Problem Statements','<h2>Domain Class</h2><p>In Object Oriented paradigm Domain Object Model has become subject of interest for its excellent problem comprehending capabilities towards the goal of designing a good software system. Domain Model, as a conceptual model gives proper understanding of problem description through its highly effective component – the Domain Classes. Domain classes are the abstraction of key entities, concepts or ideas presented in the problem statement [iv]. As stated in [v], domain classes are used for representing business activities during the analysis phase. </p><p>Below we discuss some techniques that can be used to identify the domain classes.</p><h2>Traditional Techniques for Identification of Classes</h2><h3>Grammatical Approach Using Nouns</h3><p>This object identification technique was proposed by Russell J. Abbot, and Grady Booch made the technique popular [1]. This technique involves grammatical analysis of the problem statement to identify list of potential classes. The logical steps are:<ol><li>Obtain the user requirements (problem statement) as a simple, descriptive English text. This basically corresponds to the use-case diagram for the problem statement. </li><li>Identify and mark the nouns, pronouns and noun phrases from the above problem statements</li><li>List of potential classes is obtained based on the category of the nouns (details given later). For example, nouns that direct refer to any person, place, or entity in general, correspond to different objects. And so does singular proper nouns.  On the other hand, plural nouns and common nouns are candidates that usually map into classes. </li></ol></p><h3>Advantages</h3><p>This is one of the simplest approaches that could be easily understood and applied by a larger section of the user base. The problem statement does not necessarily be in English, but in any other language.</p><h3>Disadvantages</h3><p>The problem statement always may not help towards correct identification of a class. At times it could give us redundant classes. At times the problem statement may use abbreviations for large systems or concepts, and therefore, the identified class may actually point to an aggregate of classes. In other words, it may not find all the objects.</p><h2>Using Generalization</h2><p>In this approach, all potential objects are classified into different groups based on some common behaviour. Classes are derived from these groups.</p><h2>Using Subclasses</h2><p>Here, instead of identifying objects one goes for identification of classes based on some similar characteristics. These are the specialized classes. Common characteristics are taken from them to form the higher level generalized classes.</p><h2>Steps to Identify Domain Classes from Problem Statement</h2><p>We now present the steps to identify domain classes from a given problem statement. This approach is mostly based on the "Grammatical approach using nouns" discussed above, with some insights from [i].<ol><li>Make a list of potential objects by finding out the nouns and noun phrases from narrative problem statement</li><li>Apply subject matter expertise (or domain knowledge) to identify additional classes</li><li>Filter out the redundant or irrelevant classes</li><li>Classify all potential objects based on categories. We follow the category table as described  by Ross (table 5-3, pg 88, [1])  <table class="data">  <thead>  <tr>    <th>Categories</th>	                <th>Explanation</th>  </tr>  </thead>  <tbody>  <tr>    <td>People</td>    <td>Humans who carry out some function</td>  </tr>  <tr>    <td>Places</td>    <td>Areas set aside for people or things</td>  </tr>  <tr>    <td>Things</td>    <td>Physical objects</td>  </tr>  <tr>    <td>Organizations</td>    <td>Collection of people, resources, facilities and capabilities having a defined mission</td>  </tr>  <tr>    <td>Concepts</td>    <td>Principles or Ideas not tangible</td>  </tr>  <tr>    <td>Events</td>    <td>Things that happen (usually at a given date and time), or as a steps in an ordered sequence</td>  </tr>  </tbody>  </table></li><li>Group the objects based on similar attributes. While grouping we should remember that<ul><li>Different nouns (or noun phrases) can actually refer to the same thing (examples: house, home, abode) </li><li>Same nouns (or noun phrases) could refer to different things or concepts (example: I go to school every day / This school of thought agrees with the theory) </li></ul></li><li>Give related names to each group to generate the final list of top level classes</li><li>Iterate over to refine the list of classes</li></ol></p><h2>Advanced Concepts</h2><p>Identification of domain classes might not be a simple task for novices. It requires expertise and domain knowledge to identify business classes from plain English text. The concepts presented here have been kept simple in order to make a student familiarize with the subject. A lot of work has been done in this area, and various techniques have been proposed to identify domain classes. Interested readers may look at the following paper for an advanced treatment on this subject matter.<br><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.1778&rep=rep1&type=pdf&ei=_5KtTqPLN8XMrQeZltG7DA&usg=AFQjCNFVBf-jL2ZUfyuldbJmjST1zFsrig&sig2=HRfe_1TUy4Q9UB66xduKtw&cad=rja">I. Y. Song, K. Yano, J. Trujillo, and S. Luján-Mora. "A Taxonomic Class Modeling Methodology for Object-Oriented Analysis", In <em>Information Modeling Methods and Methodologies</em>, Advanced Topics in Databases Series, Ed. (J Krostige, T. Halpin, K. Siau), Idea Group Publishing, 2004, pp. 216-240.</a></p>','<ul>  <li>Understand the concept of domain classes  <li>Identify a list of potential domain classes from a given problem statement</li>  </ul>','3.00','<p>Same types of objects are typically implemented by class in object oriented programming.  As the structural unit of the system can be represented through the classes, so, it is very important to identify the classes before start implementing all the logical flows of the system. </p><p>In this experiment we will learn how to identify the classes from a given problem statement. </p>'),
 (6,'Statechart and Activity Modeling','<h2>Statechart Diagrams</h2><p>In case of Object Oriented Analysis and Design, a system is often abstracted by one or more classes with some well defined behaviour and states. A <em>statechart diagram</em> is a pictorial representation of such a system, with all its states, and different events that lead transition from one state to another.</p><p>To illustrate this, consider a computer. Some possible states that it could have are: running, shutdown, hibernate. A transition from running state to shutdown state occur when user presses the "Power off" switch, or clicks on the "Shut down" button as displayed by the OS. Here, clicking on the shutdown button, or pressing the power off switch act as external events causing the transition.</p><p>Statechart diagrams are normally drawn to model the behaviour of a complex system. For simple systems this is optional.</p><h2>Building Blocks of a Statechart Diagram</h2><h3>State</h3><p>A state is any "distinct" stage that an object (system) passes through in its lifetime. An object remains in a given state for finite time until "something" happens, which makes it to move to another state.&nbsp; All such states can be broadly categorized into following three types:</p><ul>    <li>    <strong>Initial</strong>: The state in which an object remain when created    </li>    <li>    <strong>Final</strong>: The state from which an object do not move to any     other state [optional]    </li>    <li>    <strong>Intermediate</strong>: Any state, which is neither initial, nor     final    </li></ul><p>As shown in figure-01, an initial state is represented by a circle filled with black. An intermediate state is depicted by a rectangle with rounded corners. A final state is represented by a unfilled circle with an inner black-filled circle.<img class="diagram" src="states_symbol.png" alt="State"> <span class="diagram-label">Figure-01: Representation of initial, intermediate, and final states of a statechart diagram</span>Intermediate states usually have two compartments, separated by a horizontal line, called the name compartment and internal transitions compartment [iv]. They are described below:</p><ul>    <li>    <strong>Name compartment</strong>: Contains the name of the state, which is     a short, simple, descriptive string    </li>    <li>    <strong>Internal transitions compartment</strong>: Contains a list of     internal activities performed as long as the system is in this state    </li></ul><p>The internal activities are indicated using the following syntax: <span class="syntax">action-label / action-expression</span>. Action labels could be any condition indicator. There are, however, four special action labels:</p><ul>    <li><strong>Entry</strong>: Indicates activity performed when the system     enter this state</li>    <li><strong>Exit</strong>: Indicates activity performed when the system     exits this state</li>    <li><strong>Do</strong>: indicate any activity that is performed while the     system remain in this state or until the action expression results in a     completed computation</li>    <li><strong>Include</strong>: Indicates invocation of a sub-machine</li></ul><p>Any other action label identify the event (internal transition) as a result of which the corresponding action is triggered. Internal transition is almost similar to self transition, except that the former does not result in execution of entry and exit actions. That is, system does not exit or re-enter that state. Figure-02 shows the syntax for representing a typical (intermediate) state<img class="diagram" src="state.png" alt="State"><span class="diagram-label">Figure-02: A typical state in a statechart diagram</span>States could again be either simple or composite (a state congaing other states). Here, however, we will deal only with simple states.</p><h3>Transition</h3><p>Transition is movement from one state to another state in response to an external stimulus (or any internal event). A transition is represented by a solid arrow from the current state to the next state. It is labeled by: <span class="syntax">event [guard-condition]/[action-expression]</span>, where</p><ul>    <li><strong>Event</strong> is the what is causing the concerned transition     (mandatory) -- Written in past tense [iii]</li>    <li><strong>Guard-condition</strong> is (are) precondition(s), which must be     true for the transition to happen [optional]</li>    <li><strong>Action-expression</strong> indicate action(s) to be performed as     a result of the transition [optional]</li></ul><p>It may be noted that if a transition is triggered with one or more guard-condition(s), which evaluate to false, the system will continue to stay in the present state. Also, not all transitions do result in a state change. For example, if a queue is full, any further attempt to append will fail until the delete method is invoked at least once. Thus, state of the queue does not change in this duration.</p><h3>Action</h3><p>As mentioned in [ii], actions represents behaviour of the system. While the system is performing any action for the current event, it does not accept or process any new event. The order in which different actions are executed, is given below:</p><ol>    <li>Exit actions of the present state</li>    <li>Actions specified for the transition</li>    <li>Entry actions of the next state</li></ol><p>Figure-03 shows a typical statechart diagram with all its syntaxes.<img class="diagram" src="state_transition.png" alt="State transition"> <span class="diagram-label">Figure-03: A statechart diagram showing transition from state A to B</span></p><h2>Guidelines for drawing Statechart Diagrams</h2><p>Following steps could be followed, as suggested in [i] to draw a statechart diagram:</p><ul>    <li>For the system to developed, identify the distinct states that it passes     through</li>    <li>Identify the events (and any precondition) that cause the state     transitions. Often these would be the methods of a class as identified in a     class diagram.</li>    <li>Identify what activities are performed while the system remains in a     given state</li></ul><p>&nbsp;</p><h2>Activity Diagrams</h2><p>Activity diagrams fall under the category of behavioural diagrams in Unified Modeling Language. It is a high level diagram used to visually represent the flow of control in a system. It has similarities with traditional flow charts. However, it is more powerful than a simple flow chart since it can represent various other concepts like concurrent activities, their joining, and so on [vii, viii].</p><p>Activity diagrams, however, cannot depict the message passing among related objects. As such, it cannnot be directly translated into code. These kind of diagrams are suitable for confirming the logic to be implemented with the business users. These diagrams are typically used when the business logic is complex. In simple scenarios it can be avoided entirely [ix].</p><h2>Components of an Activity Diagram</h2><p>Below we describe the building blocks of an activity diagram.</p><h3>Activity</h3><p>An activity denotes a particular action taken in the logical flow of control. This could simply be invocation of a mathematical function, alter an object''s properties and so on [x]. An activity is represented with a rounded rectangle, as shown in Table 1. A label inside the rectangle identifies the corresponding activity.</p><p>There are two special type of activity nodes: initial and final. They are represented with a filled circle, and a filled in circle with a border respectively (Table 1). Initial node represents the starting point of a flow in an activity diagram. There could be multiple initial nodes, which means that invoking that particular activity diagram would initiate multiple flows.</p><p>A final node represents the end point of all activities. Like an initial node, there could be multiple final nodes. Any transition reaching a final node would stop all activities.</p><h3>Flow</h3><p>A flow (also termed as edge, or transition) is represented with a directed arrow. This is used to depict transfer of control from one activity to another, or to other types of components, as we will see below. A flow is often accompanied with a label, called the guard condition, indicating the necessary condition for the transition to happen. The syntax to depict it is <span class="syntax">[guard condition]</span>.</p><h3>Decision</h3><p>A decision node, represented with a diamond, is a point where a single flow enters and two or more flows leave. The control flow can follow only one of the outgoing paths. The outgoing edges often have guard conditions indicating true-false or if-then-else conditions. However, they can be omitted in obvious cases. The input edge could also have guard conditions. Alternately, a note can be attached to the decision node indicating the condition to be tested.</p><h3>Merge</h3><p>This is represented with a diamond shape, with two or more flows entering, and a single flow leaving out. A merge node represents the point where at least a single control should reach before further processing could continue.</p><h3>Fork</h3><p>Fork is a point where parallel activities begin. For example, when a student has been registered with a college, he can in parallel apply for student ID card and library card. A fork is graphically depicted with a black bar, with a single flow entering and multiple flows leaving out.</p><h3>Join</h3><p>A join is depicted with a black bar, with multiple input flows, but a single output flow. Physically it represents the synchronization of all concurrent activities. Unlike a merge, in case of a join all of the incoming controls <strong>must be completed</strong> before any further progress could be made. For example, a sales order is closed only when the customer has receive the product, <strong>and</strong> the sales company has received its payment.</p><h3>Note</h3><p>UML allows attaching a note to different components of a diagram to present some textual information. The information could simply be a comment or may be some constraint. A note can be attached to a decision point, for example, to indicate the branching criteria.</p><h3>Partition</h3><p>Different components of an activity diagram can be logically grouped into different areas, called partitions or swimlanes. They often correspond to different units of an organization or different actors. The drawing area can be partitioned into multiple compartments using vertical (or horizontal) parallel lines. Partitions in an activity diagram are not mandatory.</p><p>The following Table shows commonly used components with a typical activity diagram.</p><table class="techno" style="margin: 0 auto; width: 400px; text-align: center;">   <thead>    <tr>      <th>Component</td>      <th>Graphical Notation</td>    </tr>  </thead>  <tbody>    <tr>        <td>Activity</td>        <td><img src="activity.png" alt="Activity"></td>    </tr>    <tr>        <td>Flow</td>        <td><img src="flow.png" alt="Flow"></td>    </tr>    <tr>        <td>Decision</td>        <td><img src="decision.png" alt="Decision"></td>    </tr>    <tr>        <td>Merge</td>        <td><img src="merge.png" alt="Merge"></td>    </tr>    <tr>        <td>Fork</td>        <td><img src="fork.png" alt="Fork"></td>    </tr>    <tr>        <td>Join</td>        <td><img src="join.png" alt="Join"></td>    </tr>    <tr>        <td>Note</td>        <td><img src="note.png" alt="Note"></td>    </tr>  </tbody></table><span class="diagram-label">Table 1: Typical components used in an activity diagram</span></p><p>Apart from the above stated components, there are few other components as well (representing events, sending of signals, nested activity diagrams), which would not be discussed here. The reader is suggested to go through [x] for further knowledge.</p><h3>A Simple Example</h3><p>Figure 4 shows a simple activity diagram with two activities. The Figure depicts two stages of a form submission. At first a form is filled up with relevant and correct information. Once it is verified that there is no error in the form, it is then submitted. The two other symbols shown in the Figure are the initial node (dark filled circle), and final node (outer hollow circle with inner filled circle). It may be noted that there could be zero or more final node(s) in an activity diagram [ix]. <img src="sample_activity_dia.png" alt="Activity diagram" class="diagram"><span class="diagram-label">Figure 4: A simple activity diagram.</span></p><h2>Guidelines for drawing an Activity Diagram</h2><p>The following general guidelines could be followed to pictorially represent a complex logic.</p><ul>    <li>Identify tiny pieces of work being performed by the system</li>    <li>Identify the next logical activity that should be performed</li>    <li>Think about all those conditions that should be made, and all those     constraints that should be satisfied, before one can move to the next     activity</li>    <li>Put non-trivial guard conditions on the edges to avoid confusion</li></ul>','<ul><li>Identify the distinct states a system have</li><li>Identify the events causing transitions from one state to another</li><li>Represent the above information pictorially using simple states</li><li>Identify activities representing basic units of work, and represent their flow</li></ul>','3.00','<p>Capturing the dynamic view of a system is very important for a developer to develop the logic for a system. State chart diagrams and activity diagrams are two popular UML diagram to visualize the dynamic behavior of an information system. </p><p>In this experiment, we will learn about the different components of activity diagram and state chart diagram and how these can be used to represent the dynamic nature of an information system. </p>'),
 (7,'Modeling UML Class Diagrams and Sequence diagrams','<h2>Structural and Behavioral aspects</h2><p>Developing a software system in object oriented approach is very much dependent on understanding the problem. Some aspects and the respective models are used to describe problems and in context of those aspects the respective models give a clear idea regarding the problem to a designer. For developer, structural and behavioral aspects are two key aspects to see through a problem to design a solution for the same.</p><h2>Class diagram </h2><p>It is a graphical representation for describing a system in context of its static construction [1].</p><h2>Elements in class diagram </h2><p>Class diagram contains the system classes with its data members, operations and relationships between classes.</p><h2>Class</h2><p>A set of objects containing similar data members and member functions is described by a class. In UML syntax, class is identified by solid outline rectangle with three compartments which contain</p><ul><li><strong>Class name</strong></li><p>A class is uniquely identified in a system by its name. A textual string [2] is taken as class name. It lies in the first compartment in class rectangle.</p><li><strong>Attributes</strong></li><p>Property shared by all instances of a class. It lies in the second compartment in class rectangle.</p><li><strong>Operations</strong></li><p>An execution of an action can be performed for any object of a class. It lies in the last compartment in class rectangle.</p><p><strong>Example</strong></p><p>To build a structural model for an Educational Organization, "Course" can be treated as a class which contains attributes "courseName" &amp; "courseID" with the operations "addCourse()" &amp; "removeCourse()" allowed to be performed for any object to that class. <center><img class="diagram" src="exp71.jpg" alt="State"> Figure 1: A class with attributes and operations.</center></p><li><strong>Generalization/Specialization</strong></li><p> It describes how one class is derived from another class. Derived class inherits the properties of its parent class. </p><p><strong>Example</strong><center><img class="diagram" src="exp72.jpg" alt="State"> Figure 2: Hierarchical relationship among classes.</center></p><p>Geometric_Shapes is the class that describes how many sides a particular shape has. Triangle, Quadrilateral and Pentagon are the classes that inherit the property of the Geometric_Shapes class. So the relations among these classes are generalization. Now Equilateral_Triangle, Isosceles_Triangle and Scalene_Triangle, all these three classes inherit the properties of Triangle class as each one of them has three sides. So, these are specialization of Triangle class.</p></ul><h2>Relationships</h2><p>Existing relationships in a system describe legitimate connections between the classes in that system.</p><ul><li><strong>Association</strong></li><p>It is an instance level relationship [i] that allows exchanging messages among the objects of both ends of association. A simple straight line connecting two class boxes represent an association. We can give a name to association and also at the both end we may indicate role names and multiplicity of the adjacent classes. Association may be uni-directional. </p><p><strong>Example</strong></p><p>In structure model for a system of an organization an employee (instance of "Employee" class) is always assigned to a particular department (instance of "Department" class) and the association can be shown by a line connecting the respective classes.<center><img class="diagram" src="exp73.jpg" alt="State"> Figure 3: Association between two classes.</center></p><li><strong>Aggregation</strong></li><p>It is a special form of association which describes a part-whole [i] relationship between a pair of classes. It means, in a relationship, when a class holds some instances of related class, then that relationship can be designed as an aggregation.</p><p><strong>Example</strong></p><p>For a supermarket in a city, each branch runs some of the departments they have. So, the relation among the classes "Branch" and "Department" can be designed as an aggregation. In UML, it can be shown as in the fig. below<center><img class="diagram" src="exp74.jpg" alt="State"> Figure 4: An example of aggregation.</center></p><li></strong>Composition</strong> [i] </li><p>It is a strong from of aggregation which describes that whole is completely owns its part. Life cycle of the part depends on the whole.</p><p><strong>Example</strong></p><p>Let consider a shopping mall has several branches in different locations in a city. The existence of branches completely depends on the shopping mall as if it is not exist any branch of it will no longer exists in the city. This relation can be described as composition and can be shown as below<center><img class="diagram" src="exp75.jpg" alt="State"> Figure 5: Composition of classes.</center></p><li><strong>Multiplicity</strong></li><p>It describes how many numbers of instances of one class is related to the number of instances of another class in an association.</p><p><strong>Notation for different types of multiplicity:</strong><center><img class="diagram" src="exp77.png" alt="State"> Figure 6: Different types of multiplicities.</center></p><p><strong>Example</strong></p><p>One vehicle may have two or more wheels<center><img class="diagram" src="exp76.jpg" alt="State"> Figure 7: Multiplicity relation between a vehicle and is wheels.</center></p><!--<li><strong>Dependency</strong></li><p>This relation is presented by dotted arrow and drawn to the independent class from the class which uses it [1].</p><p><strong>Example</strong>  [1] (Figure 7.27 Page-253) </p>--></ul><p>&nbsp;</p><h2>Sequence diagram</h2><p>It represents the behavioral aspects of a system [1]. Sequence diagram shows the interactions between the objects [1] by means of passing messages from one object to another with respect to time [2] in a system.</p><h2>Elements in sequence diagram</h2><p>Sequence diagram contains the objects of a system and their life-line bar and the messages passing between them.</p><h2>Object</h2><p>Objects appear at the top portion of sequence diagram [1]. Object is shown in a rectangle box. Name of object precedes a colon ":" and the class name, from which the object is instantiated.  The whole string is underlined and appears in a rectangle box. Also, we may use only class name or only instance name.</p><!--<p><strong>Example</strong><center><img class="diagram" src="exp78.png" alt="State"> Figure 8: DIfferent types of messages.</center></p>--><p>Objects which are created at the time of execution of use case and are involved in message passing , are appear in diagram, at the point of their creation [1].</p><h2>Life-line bar</h2><p>A down-ward vertical line from object-box is shown as the life-line of the object. A rectangle bar on life-line indicates that it is active at that point of time [1].</p><h2>Messages</h2>Messages are shown as an arrow from the life-line of sender object to the life-line of receiver object and labeled with the message name. Chronological order of the messages passing throughout the objects'' life-line show the sequence in which they occur [1]. There may exist some different types of messages :<ul><li><strong>Synchronous messages:</strong> Receiver start processing the message after receiving it and sender needs to wait until it is made [iii]. A straight arrow with close and fill arrow-head from sender life-line bar to receiver end, represent a synchronous message [iii].</li><li><strong>Asynchronous messages:</strong> For asynchronous message sender needs not to wait for the receiver to process the message [iv]. A function call that creates thread can be represented as an asynchronous message in sequence diagram [iv]. A straight arrow with open arrow-head from sender life-line bar to receiver end, represent an asynchronous message [iii].</li><li><strong>Return message:</strong> For a function call when we need to return a value to the object, from which it was called, then we use return message. But, it is optional, and we are using it when we are going to model our system in much detail. A dashed arrow with open arrow-head from sender life-line bar to receiver end, represent that message.</li><li><strong>Response message:</strong>One object can send a message to self [iv].  We use this message when we need to show the interaction between the same object.</li><center><img class="diagram" src="exp79.png" alt="State"> Figure 8: Different types of messages. </center>','<ul><li>Graphically represent a class, and associations among different classes</li><li>Identify the logical sequence of activities undergoing in a system, and represent them pictorially</li></ul>','3.00','<p>Classes are the structural units in object oriented system design approach, so it is essential to know all the relationships that exist between the classes, in a system.All objects in a system are also interacting to each other by means of passing messages from one object to another. Sequence diagram shows these interactions with time ordering of the messages. </p><p>In this Experiment, we will learn about the representation of class diagram and sequence diagram. We also learn about different relationships that exist among the classes, in a system. </p><p>From the experiment of sequence diagram, we will learn about different types of messages passing in between the objects and time ordering of those messages, in a system. </p>');
INSERT INTO "isad_theory" VALUES  (8,'Modeling Data Flow Diagrams','<h2>Data Flow Diagram</h2><p>DFD provides the functional overview of a system. The graphical representation easily overcomes any gap between "user and system analyst" and "analyst and system designer" in understanding a system. Starting from an overview of the system it explores detailed design of a system through a hierarchy. DFD shows the external entities from which data flows into the process and also the other flows of data within a system. It also includes the transformations of data flow by the process and the data stores to read or write a data.</p><h2>Graphical notations for Data Flow Diagram</h2><table class="techno" style="width: 800px ;"> <thead> <tr style="text-align: center;"><th>Term</th><th>Notation</th><th>Remarks</th></tr></thead> <tbody style="text-align: left;"> <tr><td>External entity </td> <td><img alt=" External entity " src="external_entity.png"><!----></td><td> Name of the external entity is written inside the rectangle </td></tr> <tr><td>Process</td> <td><img alt=" Process " src="process.png"></td><td> Name of the process is written inside the circle </td></tr> <tr><td>Data store</td> <td><img alt=" Data store " src="data_store.png"></td><td>A left-right open rectangle is denoted as data store; name of the data store is written inside the shape </td></tr> <tr><td>Data flow</td> <td><img alt=" Data flow " src="data_flow.png"></td><td>Data flow is represented by a directed arc with its data name</td></tr></tbody></table><h2>Explanation of Symbols used in DFD</h2><p><ul><li><strong>Process</strong>:Processes are represented by circle. The name of the process is written into the circle. The name of the process is usually given in such a way that represents the functionality of the process. More detailed functionalities can be shown in the next Level if it is required. Usually it is better to keep the number of processes less than 7 [i]. If we see that the number of processes becomes more than 7 then we should combine some the processes to a single one to reduce the number of processes and further decompose it to the next level [2].</li><li><strong>External entity</strong>:External entities are only appear in context diagram [2]. External entities are represented by a rectangle and the name of the external entity is written into the shape. These send data to be processed and again receive the processed data.</li><li><strong>Data store</strong>:Data stares are represented by a left-right open rectangle. Name of the data store is written in between two horizontal lines of the open rectangle. Data stores are used as repositories from which data can be flown in or flown out to or from a process.</li><li><strong>Data flow</strong>:Data flows are shown as a directed edge between two components of a Data Flow Diagram. Data can flow from external entity to process, data store to process, in between two processes and vice-versa.</li></ul></p><h2>Context diagram and leveling DFD  </h2>We start with a broad overview of a system represented in level 0 diagram. It is known as context diagram of the system. The entire system is shown as single process and also the interactions of external entities with the system are represented in context diagram.<br>Further we split the process in next levels into several numbers of processes to represent the detailed functionalities performed by the system. Data stores may appear in higher level DFDs.<br><strong>Numbering of processes : </strong>If process "p" in context diagram is split into 3 processes "p1", "p2" and  "p3" in next level then these are labeled as 0.1, 0.2 and 0.3 in level 1 respectively. Let the process "p3" is again split into three processes "p31", "p32" and "p33" in level 2, so, these are labeled as 0.3.1, 0.3.2 and 0.3.3 respectively and so on.<br><strong>Balancing DFD: </strong>The data that flow into the process and the data that flow out to the process need to be match when the process is split into in the next level [2]. This is known as balancing a DFD.<br><br>See simulation [ii] and case study [iii] of the experiment to understand data flow diagram in more real context.<p><strong>Note : </strong></p><ol><li>External entities only appear in context diagram [2], i.e, only at level 0.</li><li>Keep number of processes at each level less than 7 [i].</li><li>Data flow is not possible in between two external entities and in between two data stores [i].</li><li>Data cannot flow from an External entity to a data store and vice-versa [i].</li></ol>','<ul><li>Identify external entities and functionalities of any system</li><li>Identify the flow of data across the system</li><li>Represent the flow with Data Flow Diagrams</li></ul>','3.00','<p>Information Systems (IS) help in managing and updating the vast business-related information. Before designing such an IS, it is helpful to identify the various stakeholders, and the information that they would be exchanging with the system. An IS, however, is a large software comprised of several modules, which, in turn, share the process the available data. These data are often stored in databases for further references. A Data Flow Diagram (DFD) is used to pictorially represent the functionalities of the ISs by focusing on the sources and destinations of the data flowing in the system.</p>'),
 (9,'Estimation of Test Coverage Metrics and Structural Complexity','<h2>Control Flow Graph</h2>    <p>A control flow graph (CFG) is a directed graph where the nodes represent different instructions of a program, and the edges define the sequence of execution of such instructions. Figure 1 shows a small snippet of code (compute the square of an integer) along with its CFG. For simplicity, each node in the CFG has been labeled with the line numbers of the program containing the instructions. A directed edge from node #1 to node #2 in Figure 1 implies that after execution of the first statement, the control of execution is transferred to the second instruction.</p><div style="padding: 5px; border: 1px solid #3399FF; width: 400px; margin: 0 auto;">    <div style="display: inline; float left; height: 300px;">        <pre style="text-align: left;" class="brush: c;">
int x = 10, x_2 = 0;
x_2 = x * x;
return x_2;        </pre>        </div>        <div style="display: inline;">        <img alt="A simple CFG"         src="t1_1_cfg_simple.png">    </div>    Figure 1: A simple program and its CFG.</div>                                <p>A program, however, does not always consist of only sequential statements. There could be branching and looping involved in it as well. Figure 2 shows how a CFG would look like if there are sequential, selection and iteration kind of statements in order.<img class="diagram" alt="CFG with branch and loop" src="t1_2_cfg_types.PNG" style="width: 383px; height: 252px;"><span class="diagram-label">  Figure 2: CFG for different types of statements.</span></p><p>A real life application seldom could be written in a few lines. In fact, it might consist of thousand of lines. A CFG for such a program is likely to become very large, and it would contain mostly straight-line connections. To simplify such a graph different sequential statements could be grouped together to form a <em>basic block</em>. A <strong>basic block</strong> is a [ii, iii] maximal sequence of program instructions I<sub>1</sub>, I<sub>2</sub>, ..., I<sub>n</sub> such that for any two adjacent instructions I<sub>k</sub> and I<sub>k+1</sub>, the following holds true:</p><ul>    <li>I<sub>k</sub> is executed immediately before I<sub>k+1</sub></li>    <li>I<sub>k+1</sub> is executed immediately after I<sub>k</sub></li>  </ul><p>The size of a CFG could be reduced by representing each basic block with a node. To illustrate this, let''s consider the following example.</p><pre class="brush: cpp;">
    sum = 0;
    i = 1;
    while (i &le; n) {
        sum += i;
        ++i;
    }
    printf("%d", sum);
    if (sum &gt; 0) {
        printf("Positive");
    }</pre><p>The CFG with basic blocks is shown for the above code in Figure 3.<img class="diagram" alt="CFG with basic blocks" src="cfg_basic_blocks.png">        <span class="diagram-label">Figure 3: Basic blocks in a CFG.</span>The first statement of a basic block is termed as <strong>leader</strong>. Any node <em>x</em> in a CFG is said to dominate another node <em>y</em> (written as <em>x dom y</em>) if all possible execution paths that goes through node <em>y</em> must pass through node <em>x</em>. The node <em>x</em> is said to be a <strong>dominator</strong> [ii]. In the above example, line #s 1, 3, 4, 6, 7, 9, 10 are leaders. The node containing lines 7, 8 dominate the node containing line # 10. The block containing line #s 1, 2 is said to be the entry block; the block containing line # 10 is said to be the exit block.</p><p>If any block (or sub-graph) in a CFG is not connected with the sub-graph containing the entry block, that signifies the concerned block contains code, which is unreachable while the program is executed. Such unreachable code can be safely removed from the program. To illustrate this, let''s consider a modified version of our previous code:</p><pre class="brush: cpp;">
    sum = 0;
    i = 1;
    while (i &le; n) {
        sum += i;
        ++i;
    }
    return sum;
    if (sum &lt; 0) {
        return 0;
    }</pre><p>Figure 4 shows the corresponding CFG. The sub-graph containing line #s 8, 9, 10 is disconnected from the graph containing the entry block. The code in the disconnected sub-graph would never get executed, and, therefore, could be discarded.<img class="diagram" alt="Unreachable blocks" src="cfg_unreachable_blocks.png"><span class="diagram-label">Figure 4: CFG with unreachable blocks.</span></p><h2>Terminologies</h2><p>    <b>Path</b><br>    A path in a CFG is a sequence of nodes and edges that starts from the     initial node (or entry block) and ends at the terminal node. The CFG of a     program could have more than one terminal nodes.</p><p>    <b>Linearly Independent Path</b><br>    A linearly independent path is any path in the CFG of a program such that it     includes at least one new edge not present in any other linearly independent     path. A set of linearly independent paths give a clear picture of all     possible paths that a program can take during its execution. Therefore, path-coverage testing of a program would suffice by considering only the     linearly independent paths.    <br>    In Figure 3 we can find four linearly independent paths:</p>    <pre>
        1 - 3 - 6 - (7, 8) - 10
        1 - 3 - 6 - (7, 8) - 9 - 10
        1 - 3 - (4, 5) - 6 - (7, 8) - 10
        1 - 3 - (4, 5) - 6 - (7, 8) - 9 - 10</pre>    <p>Note that 1 - 3 - (4, 5) - 3 - (4, 5) - 6 - (7,  8) - 10, for instance, would not qualify as a linearly independent path because there is no new edge not already present in any of the above four linearly independent paths.</p>            <h2>McCabe''s Cyclomatic Complexity</h2><p>McCabe had applied graph-theoretic analysis to determine the complexity of a program module [vi]. Cyclomatic complexity metric, as proposed by McCabe, provides an upper bound for the number of linearly independent paths that could exist through a given program module. Complexity of a module increases as the number of such paths in the module increase. Thus, if Cyclomatic complexity of any program module is 7, there could be up to seven linearly independent paths in the module. For a complete testing, each of those possible paths should be tested.</p><h3>Computing Cyclomatic Complexity</h3><p>Let <em>G</em> be a a given CFG. Let <em>E</em> denote the number of edges, and <em>N</em> denote the number of nodes. Let <em>V(G)</em> denote the Cyclomatic complexity for the CFG. <em>V(G)</em> can be obtained in either of the following three ways:</p><ul>    <li>        <b>Method #1:</b>        <span class="contentEquation">V(G) = E - N + 2</em></span>    </li>        <li>        <b>Method #2:</b>      <em>V(G)</em> could be directly computed by a visual inspection of the       CFG:    <span class="contentEquation">V(G) = Total number of bounded areas + 1    </span>    It may be noted here that structured programming would always lead to a     planar CFG.     </li>    <li>    <b>Method #3:</b>        If LN be the total number of loops and decision statements in a program,        then       <span class="contentEquation">V(G) = LN + 1</span>    </li></ul>        <p>In case of object-oriented programming, the above equations apply to methods of a class [viii].Also, the value of V(G) so obtained is incremented by 1 considering the entry point of the method. A quick summary of how different types of statements affect V(G) could be found in [ix]. Once the complexities of individual modules of a program are known, complexity of the program (or class) could be determined by [4], [ix]:<span class="contentEquation">V(G) = SUM( V(G<sub>i</sub>) ) - COUNT( V(G<sub>i</sub>) ) + 1</span>where <em>COUNT( V(G<sub>i</sub>) )</em> gives the total number of procedures (methods) in the program (class).</p><h3>Optimum Value of Cyclomatic Complexity</h3><p>A set of threshold values for Cyclomatic complexity has been presented in [vii], which we reproduce below.</p><center><table class="techno"><thead>        <tr>        <th>V(G)</th>        <th>Module Category</th>        <th>Risk</th>    </tr></thead><tbody>    <tr>        <td>1-10</td>        <td>Simple</td>        <td>Low</td>    </tr>    <tr>        <td>11-20</td>        <td>More complex</td>        <td>Moderate</td>    </tr>    <tr>        <td>21-50</td>        <td>Complex</td>        <td>High</td>    </tr>    <tr>        <td>&gt; 50</td>        <td>Unstable</td>        <td>Very high</td>    </tr></tbody></table></center><p>It has been suggested that the Cyclomatic complexity of any module should not exceed 10 [vi], [4]. Doing so would make a module difficult to understand for humans. If any module is found to have Cyclomatic complexity greater than 10, the module should be considered for redesign. Note that, a high value of V(G) is possible for a given module if it contains multiple <em>cases</em> in C like <em>switch-case</em> statements. McCabe had exempted such modules from the limit of V(G) as 10 [vi].</p>        <h3>Merits</h3><p>McCabe''s Cyclomatic complexity has certain advantages:</p><ul>    <li>Independent of programming language</li>    <li>Helps in risk analysis during development or maintenance phase</li>    <li>Gives an idea about the maximum number of test cases to be executed     (hence, the required effort) for a given module</li></ul><h3>Demerits</h3><p>Cyclomatic complexity does not reflect on cohesion and coupling of modules.</p><p>McCabe''s Cyclomatic complexity was originally proposed for procedural languages. One may look in [xi] to get an idea of how the complexity calculation could be modified for object-oriented languages. In fact, one may also wish to make use of Chidamber-Kemerer metrics [x] (or any other similar metric), which has been designed for object-oriented programming.</p>','<ul>  <li>Identify basic blocks in a program module, and draw its control flow graph (CFG)</li>  <li>Identify the linearly independent paths from a CFG</li>  <li>Determine Cyclomatic complexity of a module in a program</li></ul>','3.00','<p>A visual representation of flow of control within a program may help the developer to perform static analysis of his code. One could break down his program into multiple <i>basic blocks</i>, and connect them with directed edges to draw a Control Flow Graph (CFG). A CFG of a program helps in identifying how complex a program is. It also helps to estimate the maximum number of test cases one might require to test the code.</p><p>In this experiment, we will learn about basic blocks and how to draw a CFG using them. We would look into paths and linearly independent paths in context of a CFG. Finally, we would learn about McCabe''s cyclomatic complexity, and classify a given program based on that. </p>'),
 (10,'Designing Test Suites','<h2>Software Testing</h2><p>Testing software is an important part of the development life cycle of a software. It is an expensive activity. Hence, appropriate testing methods are necessary for ensuring the reliability of a program.According to the ANSI/IEEE 1059 standard, the definition of testing is the process of analyzing a software item, to detect the differences between existing and required conditions i.e. defects/errors/bugs and to evaluate the features of the software item. </p><p>The purpose of testing is to verify and validate a software and to find the defects present in a software. The purpose of finding those problems is to get them fixed. </p><p><ul><li><strong>Verification </strong>is the checking or we can say the testing of software for consistency and  conformance by evaluating the results against pre-specified requirements. </li><li><strong>Validation</strong> looks at the systems correctness, i.e. the process of checking that what has been specified is what the user actually wanted. </li><li><strong>Defect</strong> is a variance between the expected and actual result. The defect"s ultimate source may be traced to a fault introduced in the specification, design, or development (coding) phases. </li></ul></p><h2>Standards for Software Test Documentation</h2><p> IEEE 829-1998 is known as the 829 Standard for Software Test Documentation. It is an IEEE standard that specifies the form of a set of documents for use in software testing [i].There are other different standards discussed below.</p><p><ul><li>IEEE 1008, a standard for unit testing</li><li>IEEE 1012, a standard for Software Verification and Validation</li> <li>IEEE 1028, a standard for software inspections</li> <li>IEEE 1044, a standard for the classification of software anomalies</li><li>IEEE 1044-1, a guide to the classification of software anomalies</li><li>IEEE 830, a guide for developing system requirements specifications</li> <li>IEEE 730, a standard for software quality assurance plans</li> <li>IEEE 1061, a standard for software quality metrics and methodology</li> <li>IEEE 12207, a standard for software life cycle processes and life cycle data</li> <li>BS 7925-1, a vocabulary of terms used in software testing</li> <li>BS 7925-2, a standard for software component testing</li></ul></p><h2>Testing Frameworks</h2><p>Following are the different testing frameworks:</p><ul><li>jUnit - for Java unit test [ii]</li><li>Selenium - is a suite of tools for automating web applications for software testing purposes, plugin for Firefox [iii]<li>HP QC - is the HP Web-based test management tool. It familiarizes with the process of defining releases, specifying requirements, planning tests, executing tests, tracking defects, alerting on changes, and analyzing results. It also shows how to customize project  [iv]</li><li>IBM Rational -  Rational software has a solution to support business sector for designing, implementing and testing software [v]</li></ul><h2>Need for Software Testing</h2><p>There are many reasons for why we should test software, such as:</p><p><ul><li>Software testing identifies the software faults. The removal of faults helps reduce the number of system failures. Reducing failures improves the reliability and the quality of the systems. </li><li>Software testing can also improves the other system qualities such as maintainability, usability, and testability.</li><li>In order to meet the condition that the last few years of the 20th century systems had to be shown to be free from the "millennium bug".</li><li>In order to meet the different legal requirements.</li><li>In order to meet industry specific standards such as the Aerospace, Missile and Railway Signaling standards.</li></ul></p><h2>Test Cases and Test Suite</h2><p>A test case describes an input descriptions and an expected output descriptions. Input are of two types: preconditions (circumstances that hold prior to test case execution) and the actual inputs that are identified by some testing methods. The set of test cases is called a test suite. We may have a test suite of all possible test cases.</p><h2>Types of Software Testing</h2><p>Testing is done in every stage of software development life cycle, but the testing done at each level of software  development is different in nature and has different objectives. There are different types of testing, such as stress testing, volume testing, configuration testing, compatibility testing, recovery testing, maintenance testing, documentation testing, and usability testing. Software testing are mainly of following types [1]</p><p><ol><li><strong>Unit Testing</strong></li><li><strong>Integration Testing</strong></li><li><strong>System Testing</strong></li></ol></p><h3>Unit Testing</h3><p>Unit testing is done at the lowest level. It tests the basic unit of software, that is the smallest  testable piece of software. The individual component or unit of a program are tested in unit testing. Unit testing are of two types.<ul><li><strong>Black box testing</strong>: This is also known as <strong>functional testing</strong> , where the test cases are designed based on input output values only. There are many types of Black Box Testing but following are the prominent ones.</li></ul></p><p>- <strong> Equivalence class partitioning</strong>: In this approach, the domain of input values to a program is divided into a set of equivalence classes.e.g. Consider a software program that computes whether an integer number is  even or not that is in the range of 0 to 10. Determine the equivalence class test suite.There are three equivalence classes for this program.- The set of negative integer- The integers in the range 0 to 10- The integer larger than 10</p><p>- <strong> Boundary value analysis </strong>: In this approach, while designing the test cases, the values at boundaries of different equivalence classes are taken into consideration.e.g. In the above given example as in equivalence class partitioning, a boundary values based test suite is { 0, -1, 10, 11 }</p><p><ul><li><strong>White box testing</strong>: It is also known as <strong>structural testing</strong>. In this testing, test cases are designed on the basis of examination of the code.This testing is performed based on the knowledge of how the system is implemented. It includes analyzing data flow, control flow, information flow, coding practices, exception and error handling within the system, to test the intended and unintended software behavior. White box testing can be performed to validate whether code implementation follows intended design, to validate implemented security functionality, and to uncover exploitable vulnerabilities.This testing requires access to the source code. Though white box testing can be performed any time in the life cycle after the code is developed, but it is a good practice to perform white box testing during the unit testing phase. </li></ul></p><h3>Integration Testing</h3><p>Integration testing is performed when two or more tested units are combined into a larger structure. The main objective of this testing is to check whether the different modules of a program interface with each other properly or not. This testing is mainly of two types:</p> <p><ul> <li><strong> Top-down approach</strong></li><li><strong>Bottom-up approach</strong></li></ul></p> <p>In bottom-up approach, each subsystem is tested separately and then the full system is tested. But the top-down integration testing starts with the main routine and one or two subordinate routines in the system. After the top-level "skeleton" has been tested, the immediately subroutines of the "skeleton" are combined with it and tested.</p><h3>System Testing</h3><p>System testing tends to affirm the end-to-end quality of the entire system. System testing is often based  on the functional / requirement specification of the system. Non-functional quality attributes, such as  reliability, security, and maintainability are also checked. There are three types of system testing</p><ul><li><strong>Alpha testing</strong> is done by the developers who develop the software. This testing is also done by the client or an outsider with the presence of developer or we can say tester.</li><li><strong>Beta testing</strong>is done by very few number of end users before the delivery, where the change requests are fixed, if the user gives any feedback or reports any type of defect.</li><li><strong>User Acceptance testing </strong>is also another level of the system testing process where the system is tested for acceptability. This test evaluates the system''s compliance with the client requirements and assess whether it is acceptable for software delivery</ul></p><p>An error correction may introduce new errors. Therefore, after every round of error-fixing, another testing is carried out, i.e. called regression testing. Regression testing does not belong to either unit testing, integration testing, or system testing, instead, it is a separate dimension to these three forms of testing.</p><p><strong>Regression Testing</strong></p><p>The purpose of regression testing is to ensure that bug fixes and new functionality introduced in a software do not adversely affect the unmodified parts of the program [2]. Regression testing is an important activity at both testing and maintenance phases. When a piece of software is modified, it is necessary to ensure that the quality of the software is preserved. To this end, regression testing is to retest the software using the test cases selected from the original test suite. </p><h3>Example</h3><p>Write a program to calculate the square of a number in the range 1-100 </p><p><pre class="brush: cpp;"
>#include &lt;stdio.h&gt;
int main()  {
     int n, res;
     printf("Enter a number: ");
     scanf("%d", &n);
     if (n &gt;= 1 && n &lt;= 100)
     {
         res = n * n;
          printf("\n Square of %d is %d\n", n, res);
     }
     else if (n &lt;= 0 || n &gt; 100)
         printf("Beyond the range");

      return 0;
}</pre></p><p>Output</p><p><pre class="brush: bash;">
Inputs               Outputs
I1 :  -2        O1 :  Beyond the range
I2 :   0        O2 :  Beyond the range
I3 :   1        O3 :  Square of 1 is 1
I4 : 100        O4 :  Square of 100 is 10000
I5 : 101        O5 :  Beyond the range
I6 :   4        O6 :  Square of 4 is 16
I7 :  62        O7 :  Square of 62 is 3844</pre></p><p>Test Cases</p><p><pre class="brush: bash;">
T1 : {I1 ,O1}
T2 : {I2 ,O2}
T3 : {I3, O3}
T4 : {I4, O4}
T5 : {I5, O5}
T6 : {I6, O6}
T7 : {I7, O7}</pre></p><h2>Some Remarks</h2><p>A prevalent misconception among the beginners is that one should be concerned with testing only after coding ends. Testing is, in fact, not a phase towards the end. It is rather a continuous process. The efforts for testing should begin in the form of preparation of test cases after the requirements have been finalized. The Software Requirements Specification (SRS) document captures all features to be expected from the system. The requirements so identified here should serve as a basis towards preparation of the test cases. Test cases should be designed in such a way that all target features could be verified. However,testing a software is not only about proving that it works correctly. Successful testing should also point out the bugs present in the system, if any.</p>','<ul><li>Learn about different techniques of testing a software</li><li>Design unit test cases to verify the functionality and locate bugs, if any </li></ul>','3.00','<p>Development of a new software, like any other product, remains incomplete until it subjected to exhaustive tests. The primary objective of testing is not only to verify that all desired features have been implemented correctly, but also includes the verification of the software behavior in case of &quot;bad inputs&quot;.</p><p>In this experiment we discuss in brief about different types of testing, and provide tools and mechanisms to have hands-on experience on unit testing.</p>');
